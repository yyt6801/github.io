[{"categories":["计算机基础知识"],"content":"URL编码表 字符 编码 backspace %08 tab %09 linefeed %0A creturn %0D space %20 ! %21 \" %22 # %23 $ %24 % %25 \u0026 %26 ' %27 ( %28 ) %29 * %2A + %2B , %2C - %2D . %2E / %2F 0 %30 1 %31 2 %32 3 %33 4 %34 5 %35 6 %36 7 %37 8 %38 9 %39 : %3A ; %3B \u003c %3C = %3D \u003e %3E @ %40 A %41 B %42 C %43 D %44 E %45 F %46 G %47 H %48 I %49 J %4A K %4B L %4C M %4D N %4E O %4F P %50 Q %51 R %52 S %53 T %54 U %55 V %56 W %57 X %58 Y %59 Z %5A [ %5B \\ %5C ] %5D ^ %5E _ %5F ` %60 a %61 b %62 c %63 d %64 e %65 f %66 g %67 h %68 i %69 j %6A k %6B l %6C m %6D n %6E o %6F p %70 q %71 r %72 s %73 t %74 u %75 v %76 w %77 x %78 y %79 z %7A { %7B } %7D ~ %7E ￠ % A2 ￡ % A3 ￥ % A5 § %A7 « %AB ¬ %AC ˉ %AD o %B0 ± %B1 a %B2 , %B4 μ %B5 » %BB ¼ %BC ½ %BD ¿ %BF à %C0 á %C1 Ã %C3 Ä %C4 Å %C5 Æ %C6 Ç %C7 è %C8 é　%C9 ê %CA Ë %CB ì　%CC í %CD Î %CE Ï %CF D %D0 Ñ %D1 ò %D2 ó %D3 Ô %D4 Õ %D5 Ö %D6 Ø %D8 ù %D9 ú　%DA Û %DB ü %DC Y %DD T %DE ß %DF à %E0 á %E1 a %E2 ã %E3 ä %E4 å %E5 æ %E6 ç %E7 è %E8 é %E9 ê %EA ë %EB ì %EC í %ED î %EE ï %EF e %F0 ñ %F1 ò %F2 ó %F3 ô %F4 õ %F5 ö %F6 ÷　%F7 ø %F8 ù %F9 ú　%FA û %FB ü %FC y %FD t %FE ÿ %FF ","date":"2022-12-08","objectID":"/posts/url%E7%BC%96%E7%A0%81%E8%A1%A8/:0:0","tags":["编码","URL"],"title":"URL编码表","uri":"/posts/url%E7%BC%96%E7%A0%81%E8%A1%A8/"},{"categories":null,"content":"About Me. ","date":"2022-12-07","objectID":"/about/:0:0","tags":null,"title":"关于","uri":"/about/"},{"categories":null,"content":"docker 使用场景: Docker提供了轻量级的虚拟化，它几乎没有任何额外开销，这个特性非常酷。 首先你在享有Docker带来的虚拟化能力的时候无需担心它带来的额外开销。其次，相比于虚拟机，你可以在同一台机器上创建更多数量的容器。 Docker的另外一个优点是容器的启动与停止都能在几秒中内完成。 ","date":"2022-12-01","objectID":"/posts/docker-basic-operation-guide/:0:0","tags":null,"title":"Docker常用操作","uri":"/posts/docker-basic-operation-guide/"},{"categories":null,"content":"1. 简化配置 虚拟机的最大好处是能在你的硬件设施上运行各种配置不一样的平台（软件、系统），Docker在降低额外开销的情况下提供了同样的功能。它能让你将运行环境和配置放在代码中然后部署，同一个Docker的配置可以在不同的环境中使用，这样就降低了硬件要求和应用环境之间耦合度。 ","date":"2022-12-01","objectID":"/posts/docker-basic-operation-guide/:0:1","tags":null,"title":"Docker常用操作","uri":"/posts/docker-basic-operation-guide/"},{"categories":null,"content":"2. 代码流水线（Code Pipeline）管理 前一个场景对于管理代码的流水线起到了很大的帮助。代码从开发者的机器到最终在生产环境上的部署，需要经过很多的中间环境。而每一个中间环境都有自己微小的差别，Docker给应用提供了一个从开发到上线均一致的环境，让代码的流水线变得简单不少。 ","date":"2022-12-01","objectID":"/posts/docker-basic-operation-guide/:0:2","tags":null,"title":"Docker常用操作","uri":"/posts/docker-basic-operation-guide/"},{"categories":null,"content":"3. 提高开发效率 这就带来了一些额外的好处：Docker能提升开发者的开发效率。 不同的开发环境中，我们都想把两件事做好。一是我们想让开发环境尽量贴近生产环境，二是我们想快速搭建开发环境。 理想状态中，要达到第一个目标，我们需要将每一个服务都跑在独立的虚拟机中以便监控生产环境中服务的运行状态。然而，我们却不想每次都需要网络连接，每次重新编译的时候远程连接上去特别麻烦。这就是Docker做的特别好的地方，开发环境的机器通常内存比较小，之前使用虚拟机的时候，我们经常需要为开发环境的机器加内存，而现在Docker可以轻易的让几十个服务在Docker中跑起来。 ","date":"2022-12-01","objectID":"/posts/docker-basic-operation-guide/:0:3","tags":null,"title":"Docker常用操作","uri":"/posts/docker-basic-operation-guide/"},{"categories":null,"content":"4. 隔离应用 有很多种原因会让你选择在一个机器上运行不同的应用，比如之前提到的提高开发效率的场景等。 我们经常需要考虑两点，一是因为要降低成本而进行服务器整合，二是将一个整体式的应用拆分成松耦合的单个服务（微服务架构）。如果你想了解为什么松耦合的应用这么重要，请参考Steve Yege的这篇论文，文中将Google和亚马逊做了比较。 ","date":"2022-12-01","objectID":"/posts/docker-basic-operation-guide/:0:4","tags":null,"title":"Docker常用操作","uri":"/posts/docker-basic-operation-guide/"},{"categories":null,"content":"5. 整合服务器 正如通过虚拟机来整合多个应用，Docker隔离应用的能力使得Docker可以整合多个服务器以降低成本。由于没有多个操作系统的内存占用，以及能在多个实例之间共享没有使用的内存，Docker可以比虚拟机提供更好的服务器整合解决方案。 ","date":"2022-12-01","objectID":"/posts/docker-basic-operation-guide/:0:5","tags":null,"title":"Docker常用操作","uri":"/posts/docker-basic-operation-guide/"},{"categories":null,"content":"6. 调试能力 Docker提供了很多的工具，这些工具不一定只是针对容器，但是却适用于容器。它们提供了很多的功能，包括可以为容器设置检查点、设置版本和查看两个容器之间的差别，这些特性可以帮助调试Bug。你可以在《Docker拯救世界》的文章中找到这一点的例证。 ","date":"2022-12-01","objectID":"/posts/docker-basic-operation-guide/:0:6","tags":null,"title":"Docker常用操作","uri":"/posts/docker-basic-operation-guide/"},{"categories":null,"content":"7. 多租户环境 另外一个Docker有意思的使用场景是在多租户的应用中，它可以避免关键应用的重写。我们一个特别的关于这个场景的例子是为IoT（物联网）的应用开发一个快速、易用的多租户环境。这种多租户的基本代码非常复杂，很难处理，重新规划这样一个应用不但消耗时间，也浪费金钱。 使用Docker，可以为每一个租户的应用层的多个实例创建隔离的环境，这不仅简单而且成本低廉，当然这一切得益于Docker环境的启动速度和其高效的diff命令。 ","date":"2022-12-01","objectID":"/posts/docker-basic-operation-guide/:0:7","tags":null,"title":"Docker常用操作","uri":"/posts/docker-basic-operation-guide/"},{"categories":null,"content":"8. 快速部署 在虚拟机之前，引入新的硬件资源需要消耗几天的时间。虚拟化技术（Virtualization）将这个时间缩短到了分钟级别。而Docker通过为进程仅仅创建一个容器而无需启动一个操作系统，再次将这个过程缩短到了秒级。这正是Google和Facebook都看重的特性。 你可以在数据中心创建销毁资源而无需担心重新启动带来的开销。通常数据中心的资源利用率只有30%，通过使用Docker并进行有效的资源分配可以提高资源的利用率。 docker使用基本操作 ","date":"2022-12-01","objectID":"/posts/docker-basic-operation-guide/:0:8","tags":null,"title":"Docker常用操作","uri":"/posts/docker-basic-operation-guide/"},{"categories":null,"content":"开启docker服务 sudo service docker start\r","date":"2022-12-01","objectID":"/posts/docker-basic-operation-guide/:1:0","tags":null,"title":"Docker常用操作","uri":"/posts/docker-basic-operation-guide/"},{"categories":null,"content":"搜索镜像 docker search mongo\r","date":"2022-12-01","objectID":"/posts/docker-basic-operation-guide/:2:0","tags":null,"title":"Docker常用操作","uri":"/posts/docker-basic-operation-guide/"},{"categories":null,"content":"拉取镜像到本地 docker pull mongo\rdocker pull mysql:5.6 拉取5.6版本的mysql镜像\r","date":"2022-12-01","objectID":"/posts/docker-basic-operation-guide/:3:0","tags":null,"title":"Docker常用操作","uri":"/posts/docker-basic-operation-guide/"},{"categories":null,"content":"查看所有镜像 docker images -a\r","date":"2022-12-01","objectID":"/posts/docker-basic-operation-guide/:4:0","tags":null,"title":"Docker常用操作","uri":"/posts/docker-basic-operation-guide/"},{"categories":null,"content":"把镜像做成容器并运行 docker run --name mongodb -v ~/docker/mongo:/data/db -p 27017:27017 -d mongo\r通过在创建容器时设置MONGO_INITDB_ROOT_USERNAME和MONGODB_INITDB_ROOT_PASSWORD环境变量来添加初始用户帐户 docker run -d --name mongodb -v /mydata/mongodb/datadb:/data/db -p 27017:27017 -e MONGO_INITDB_ROOT_USERNAME=admin -e MONGO_INITDB_ROOT_PASSWORD=admin --privileged=true mongo 运行mysql5.6 docker run -p 3306:3306 --name mymysql -v $PWD/test-mysql/conf:/etc/mysql/conf.d -v $PWD/test-mysql/logs:/logs -v $PWD/test-mysql/data:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=123456 -d mysql:5.6 ","date":"2022-12-01","objectID":"/posts/docker-basic-operation-guide/:5:0","tags":null,"title":"Docker常用操作","uri":"/posts/docker-basic-operation-guide/"},{"categories":null,"content":"各参数含义: --name 设置了容器的自定义名字 -v 设置了路径的映射, 将本地路径映射到容器中（把一个本地/宿主机上的目录挂载到镜像里）. 此处, 路径可以自定义：冒号前为宿主机目录，必须为绝对路径，冒号后为镜像内挂载的路径。 -v $PWD/conf:/etc/mysql/conf.d：将主机当前目录下的 conf/my.cnf 挂载到容器的 /etc/mysql/my.cnf -v $PWD/logs:/logs：将主机当前目录下的 logs 目录挂载到容器的 /logs -v $PWD/data:/var/lib/mysql ：将主机当前目录下的data目录挂载到容器的 /var/lib/mysql -p 设置了端口的映射(主机在前，容器在后), 将容器的27017端口映射到了本地的27017端口(map port 27017 of the host to port 27017 in the container) 注： -P参数会随机分配一个49000~49900之间的端口到容器内部开放的网络（通过EXPORT指定的）端口 -p则可以具体指定要映射的端口，并且在一个指定端口上只能绑定一个容器 例如：-p 127.0.0.1:5001:5000 通过访问 127.0.0.1:5001 来访问容器的 5000 端口 -d 设置当前容器为守护进程,后台运行 -e MYSQL_ROOT_PASSWORD=123456：初始化 root 用户的密码。 例: 构建nginx容器映射到本机html目录中 docker run --name nginx -d -p 80:80 -v /my_folder/my_nginx/html:/usr/share/nginx/html -v /my_folder/my_nginx/logs:/var/log/nginx nginx ","date":"2022-12-01","objectID":"/posts/docker-basic-operation-guide/:5:1","tags":null,"title":"Docker常用操作","uri":"/posts/docker-basic-operation-guide/"},{"categories":null,"content":"查看所有的容器 docker ps -a\r","date":"2022-12-01","objectID":"/posts/docker-basic-operation-guide/:6:0","tags":null,"title":"Docker常用操作","uri":"/posts/docker-basic-operation-guide/"},{"categories":null,"content":"开启/关闭容器 docker start/stop +CONTAINER_NAME\r","date":"2022-12-01","objectID":"/posts/docker-basic-operation-guide/:7:0","tags":null,"title":"Docker常用操作","uri":"/posts/docker-basic-operation-guide/"},{"categories":null,"content":"查看容器详细信息: docker inspect +CONTAINER_NAME\r","date":"2022-12-01","objectID":"/posts/docker-basic-operation-guide/:8:0","tags":null,"title":"Docker常用操作","uri":"/posts/docker-basic-operation-guide/"},{"categories":null,"content":"进入容器交互模式: docker exec -it mongodb bash 使用交互的形式, 在 名字为 mongodb 的容器中实行 bash这个命令 ","date":"2022-12-01","objectID":"/posts/docker-basic-operation-guide/:9:0","tags":null,"title":"Docker常用操作","uri":"/posts/docker-basic-operation-guide/"},{"categories":null,"content":"删除某容器 docker rm +CONTAINER_NAME\r","date":"2022-12-01","objectID":"/posts/docker-basic-operation-guide/:10:0","tags":null,"title":"Docker常用操作","uri":"/posts/docker-basic-operation-guide/"},{"categories":null,"content":"删除某镜像 docker rmi +IMAGE_NAME\r","date":"2022-12-01","objectID":"/posts/docker-basic-operation-guide/:11:0","tags":null,"title":"Docker常用操作","uri":"/posts/docker-basic-operation-guide/"},{"categories":null,"content":"更新镜像 通过命令 docker commit来提交容器副本 docker commit -m=\"has update\" -a=\"runoob\" e218edb10161 +NEW_IMAGE_NAME:+TAG_NAME 各个参数说明： -m:提交的描述信息 -a:指定镜像作者 e218edb10161：容器ID runoob/ubuntu:v2:指定要创建的目标镜像名和标签名 ","date":"2022-12-01","objectID":"/posts/docker-basic-operation-guide/:12:0","tags":null,"title":"Docker常用操作","uri":"/posts/docker-basic-operation-guide/"},{"categories":null,"content":"交互模式下常用vim编辑,需更新安装vim: 更新源 apt-get update\r安装 vim apt-get install vim\r修改 mongo 配置文件 vim /etc/mongod.conf.orig 关于使用docker的一些问题: Q: 修改部署的容器配置,如tomcat中的一些端口配置等的修改 A: 通过vim编辑修改? Q:随机端口映射,如何设置 A:用-P为随机端口映射,用-p为制定端口映射.但同一端口不能被两个容器使用. Q:已配置好的容器如何运行到其他电脑中? 如果跨平台呢? A:把容器打包save成镜像 安装和常用CLI： 添加阿里云镜像：sudo yum-config-manager –add-repo https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo 安装命令：sudo yum install -y docker-ce docker-ce-cli containerd.io 启动命令：sudo systemctl start docker 添加当前用户到docker用户组：sudo usermod -aG docker $USER （需注销），newgrp docker （立即生效） Helloworld：docker run hello-world （本地没有镜像的话会自动从远端仓库pull） pull nginx 镜像：docker pull nginx（等效于nginx:latest） 运行：docker run -【d】（后台运行不阻塞shell） 【-p 80:80】（指定容器端口映射，内部：外部） nginx 查看正在运行：docker ps 删除容器：docker rm -f \u003ccontainer id(不用打全，前缀区分)\u003e 进入bash：docker exec -it \u003ccontainer id(不用打全，前缀区分)\u003e bash commit镜像：docker commit \u003ccontainer id(不用打全，前缀区分)\u003e 查看镜像列表：docker images （刚才commit的镜像） 使用运行刚才commit的镜像：docker run -d 使用Dockerfile构建镜像：docker build -t \u003c存放Dockerfile的文件夹\u003e 删除镜像：docker rmi 保存为tar：docker save \u003e 从tar加载：docker load \u003c 一些启动参数： 后台运行容器：-d 容器内外端口映射：-p 内部端口号:外部端口号 目录映射：-v ‘dir name’ : 指定映像版本：: docker中宿主机与容器（container）互相拷贝传递文件的方法 ","date":"2022-12-01","objectID":"/posts/docker-basic-operation-guide/:12:1","tags":null,"title":"Docker常用操作","uri":"/posts/docker-basic-operation-guide/"},{"categories":null,"content":"1、从容器拷贝文件到宿主机 docker cp mycontainer:/opt/testnew/file.txt /opt/test/ ","date":"2022-12-01","objectID":"/posts/docker-basic-operation-guide/:12:2","tags":null,"title":"Docker常用操作","uri":"/posts/docker-basic-operation-guide/"},{"categories":null,"content":"2、从宿主机拷贝文件到容器 docker cp /opt/test/file.txt mycontainer:/opt/testnew/ ","date":"2022-12-01","objectID":"/posts/docker-basic-operation-guide/:12:3","tags":null,"title":"Docker常用操作","uri":"/posts/docker-basic-operation-guide/"},{"categories":null,"content":"1、 根据requirements.txt 和Dockerfile打包成镜像 docker build -t docker-flask:0.1 . 注意最后一个点 ","date":"2022-12-01","objectID":"/posts/docker-basic-operation-guide/:12:4","tags":null,"title":"Docker常用操作","uri":"/posts/docker-basic-operation-guide/"},{"categories":null,"content":"2、 将镜像运行(容器运行)，后台-d，映射-v docker run -d --name flask_app -v $PWD/app:/app -p 5000:5000 docker-flask:0.2 ","date":"2022-12-01","objectID":"/posts/docker-basic-operation-guide/:12:5","tags":null,"title":"Docker常用操作","uri":"/posts/docker-basic-operation-guide/"},{"categories":null,"content":"1、 在本地新建文件夹，把远程仓库的克隆到本地: a) git clone URL 2、 本地修改后同步到远程仓库： a) git status (查看本地是否跟踪到) b) git add . (把本地新增的文件添加到缓存) c) 再执行 git status 查看是否已存放至暂存区 d) git commit –m \"changes\" (使用 git add 命令将想要快照的内容写入缓存区， 而执行 git commit 将缓存区内容添加到仓库中。) e) git push (把本地代码放到远程仓库) 3、 在本地仓库获取同步最新远程仓库： 方法一： git fetch 在本地仓库获取最新的代码同步（常用），检查更新，但并未改动本地文件；之后需要加上 git merge 才将本地仓库进行同步。 至此，修改全部结束。 方法二： 直接 git pull 即可实现同步： (在本地pull远程仓库最新的代码到本地仓库，相当于 git fetch + git merge ) 4、 取消本地修改内容 git checkout -- filename filename填写需要撤销修改的文件名(需包含路径)，可以清空所修改内容 git checkout . 可清空本地仓库所有未提交的修改 ","date":"2022-12-01","objectID":"/posts/git-basic-operation-guide/:0:0","tags":null,"title":"Git常用操作","uri":"/posts/git-basic-operation-guide/"},{"categories":null,"content":"将本地代码上传到git新仓库中 1.本地仓库中添加Readme.md文件和.gitignore文件 2.初始化仓库 git init 3.添加当前目录下的所有文件到暂存区： git add . 4.将暂存区内容添加到本地仓库中。： git commit -m \"first commit\" 5.将本地仓库和github远程仓库绑定：git remote add origin https://github.com/....git 6.提交至远程仓库：git push -u origin main ","date":"2022-12-01","objectID":"/posts/git-basic-operation-guide/:1:0","tags":null,"title":"Git常用操作","uri":"/posts/git-basic-operation-guide/"},{"categories":null,"content":"在新环境中与仓库连接: ssh key是连接你的电脑和GitHub服务器的一把钥匙，只有两者建立了联系才能把你本地的代码提交到github上。首先要获取到ssh key公钥。 1.在终端输运行命令： ssh-keygen 获取ssh-key; 把生成文件夹中的id_rsa.pub内容(获取到的ssh-key)复制到github自己账户setting中,然后回到终端，设置用户名和邮箱，最好与注册的github一致。这个用户名和邮箱是非常重要的，因为每次Git提交都会使用该信息。它被永远的嵌入到了你的提交中。在团队开发中，可以清楚地看到是谁的提交。 在终端中输入命令： git config 'user.name' git config 'useremail@xx' 接下来把仓库clone到本地,修改后 git commit -am \"xxx\" 提交; 再 git push 即可. ","date":"2022-12-01","objectID":"/posts/git-basic-operation-guide/:2:0","tags":null,"title":"Git常用操作","uri":"/posts/git-basic-operation-guide/"},{"categories":null,"content":"git 使用 ssh 方式clone和push 无需用户名密码 若用的是https而不是ssh则每次操作仍需账号和密码。 可以更新一下origin git remote remove origin git remote add origin git@github.com:Username/Your_Repo_Name.git 之后你还需要重新设置track branch，比如： 先 git pull 然后执行： git branch --set-upstream-to=origin/master master 即可完成使用ssh连接本地 ","date":"2022-12-01","objectID":"/posts/git-basic-operation-guide/:2:1","tags":null,"title":"Git常用操作","uri":"/posts/git-basic-operation-guide/"},{"categories":null,"content":"git分支操作： $ git checkout -b iss1 新建一个分支并同时切换到那个分支上 Switched to a new branch \"iss1\" 它是下面两条命令的简写： $ git branch iss1 $ git checkout iss1 开始在分支中修改代码… … 修改完成，开始提交到分支iss1 $ git commit -am \"fix iss1\" 提交完成后先不要push，切换回master后 需要把分支iss1 合并到master中: $ git checkout master 切换回master $ git merge iss1 把iss1合并到当前master中 Updating f42c576..3a0874c Fast-forward index.html | 2 ++ 1 file changed, 2 insertions(+) 合并完成 现在分支的修改已完全合并到master中，可以删除分支iss1，然后再push到远程中： $ git branch -d iss1 删除分支iss1 $ git push 把当前的修改push到远程仓库中 ","date":"2022-12-01","objectID":"/posts/git-basic-operation-guide/:3:0","tags":null,"title":"Git常用操作","uri":"/posts/git-basic-operation-guide/"},{"categories":null,"content":"回退命令git reset： $ git reset --hard HEAD^ 回退到上个版本 $ git reset --hard HEAD~3 回退到前3次提交之前，以此类推，回退到n次提交之前 $ git reset --hard commit_id 退到/进到 指定commit的sha码 ","date":"2022-12-01","objectID":"/posts/git-basic-operation-guide/:4:0","tags":null,"title":"Git常用操作","uri":"/posts/git-basic-operation-guide/"},{"categories":null,"content":"修改已提交命令git rebase： $ git rebase -i 弹出交互式的界面让用户编辑完成合并操作 上面未被注释的部分列出的是我们本次rebase操作包含的所有提交，下面注释部分是git为我们提供的命令说明。每一个commit id 前面的pick表示指令类型，git为我们提供了以下几个命令： pick：保留该commit（缩写：p） reword：保留该commit，但我需要修改该commit的注释（缩写：r） edit：保留该commit, 但我要停下来修改该提交（不仅仅修改注释）（缩写：e） squash：将该commit和前一个commit合并（缩写：s） fixup：将该commit和前一个commit合并，但我不要保留该提交的注释信息（缩写：f） exec：执行shell命令（缩写：x） drop：我要丢弃该commit（缩写：d） 把对应commit前改为edit可修改此次提交，修改完后重新提交即可； ","date":"2022-12-01","objectID":"/posts/git-basic-operation-guide/:5:0","tags":null,"title":"Git常用操作","uri":"/posts/git-basic-operation-guide/"},{"categories":null,"content":"git 基本操作注意点总结: git clone \u003csource repository\u003e \u003cdestination repository\u003e 复制本地仓库的命令方式。其中 \u003csource repository\u003e ：想克隆的本地仓库路径。 \u003cdestination repository\u003e：想克隆去另一个地方的路径。 例如： git clone d:/git e:/git11 是将 d:/git 的仓库（即包含隐藏文件 .git 的目录）克隆到 e:/git11 目录下。 注意： 1、\u003cdestination repository\u003e 目录必须没有在文件系统上创建，或创建了但里面为空，不然会克隆不成功。 2、与从远程拉取仓库不同，路径的最后不用写 .git 来表明这是一个仓库。 git status –s 获得简短的状态输出。 git diff ：查看工作区与暂存区的不同。 git diff –cached [\u003ccommit\u003e] ：查看暂存区与指定提交版本的不同，版本可缺省（为HEAD）。 git diff \u003ccommit\u003e：查看工作区与指定提交版本的不同。 git diff \u003ccommit\u003e..\u003ccommit\u003e：查看2个指定提交版本的不同，其中任一可缺省（为HEAD）。 git diff \u003ccommit\u003e...\u003ccommit\u003e：查看2个不同分支指定提交版本的不同，其中任一可缺省（为HEAD），该命令相当于 git diff $(git-merge-base A B) B git commit –am \"\" 直接提交全部修改，相当于 add 和 commit 一起执行了。 注意：全部文件为 tracked 才行，你新建了文件为 untracked 时，该命令不会执行 git checkout 与 git reset 不同，reset 是替换整个目录树，多余的文件将被删除。而 checkout 只是替换指定的文件，对多余的文件保留不做任何处理。 git rm 把文件从工作区和暂存区中删除。使用 —cached 只从暂存区中删除。使用 –rf \u003cdirectory\u003e 可删除指定目录下的所有文件和子目录。 git mv \u003csource\u003e \u003cdestination\u003e 在工作区和暂存区中进行移动或重命名。若 \u003cdestination\u003e 不为一个目录名，则执行重命名。如果为一个目录名，则执行移动。 ","date":"2022-12-01","objectID":"/posts/git-basic-operation-guide/:6:0","tags":null,"title":"Git常用操作","uri":"/posts/git-basic-operation-guide/"},{"categories":["计算机基础知识"],"content":"//这是整理之后的ASCII码对照表和键值码对照表 ASCII码 Bin Dec Hex 缩写/字符 解释 00000000 0 00 NUL(null) 空字符 00000001 1 01 SOH(start of headling) 标题开始 00000010 2 02 STX (start of text) 正文开始 00000011 3 03 ETX (end of text) 正文结束 00000100 4 04 EOT (end of transmission) 传输结束 00000101 5 05 ENQ (enquiry) 请求 00000110 6 06 ACK (acknowledge) 收到通知 00000111 7 07 BEL (bell) 响铃 00001000 8 08 BS (backspace) 退格 00001001 9 09 HT (horizontal tab) 水平制表符 00001010 10 0A LF (NL line feed, new line) 换行键 00001011 11 0B VT (vertical tab) 垂直制表符 00001100 12 0C FF (NP form feed, new page) 换页键 00001101 13 0D CR (carriage return) 回车键 00001110 14 0E SO (shift out) 不用切换 00001111 15 0F SI (shift in) 启用切换 00010000 16 10 DLE (data link escape) 数据链路转义 00010001 17 11 DC1 (device control 1) 设备控制1 00010010 18 12 DC2 (device control 2) 设备控制2 00010011 19 13 DC3 (device control 3) 设备控制3 00010100 20 14 DC4 (device control 4) 设备控制4 00010101 21 15 NAK (negative acknowledge) 拒绝接收 00010110 22 16 SYN (synchronous idle) 同步空闲 00010111 23 17 ETB (end of trans. block) 传输块结束 00011000 24 18 CAN (cancel) 取消 00011001 25 19 EM (end of medium) 介质中断 00011010 26 1A SUB (substitute) 替补 00011011 27 1B ESC (escape) 溢出 00011100 28 1C FS (file separator) 文件分割符 00011101 29 1D GS (group separator) 分组符 00011110 30 1E RS (record separator) 记录分离符 00011111 31 1F US (unit separator) 单元分隔符 00100000 32 20 (space) 空格 00100001 33 21 ! 00100010 34 22 \" 00100011 35 23 # 00100100 36 24 $ 00100101 37 25 % 00100110 38 26 \u0026 00100111 39 27 ' 00101000 40 28 ( 00101001 41 29 ) 00101010 42 2A * 00101011 43 2B + 00101100 44 2C , 00101101 45 2D - 00101110 46 2E . 00101111 47 2F / 00110000 48 30 0 00110001 49 31 1 00110010 50 32 2 00110011 51 33 3 00110100 52 34 4 00110101 53 35 5 00110110 54 36 6 00110111 55 37 7 00111000 56 38 8 00111001 57 39 9 00111010 58 3A : 00111011 59 3B ; 00111100 60 3C \u003c 00111101 61 3D = 00111110 62 3E \u003e 00111111 63 3F ? 01000000 64 40 @ 01000001 65 41 A 01000010 66 42 B 01000011 67 43 C 01000100 68 44 D 01000101 69 45 E 01000110 70 46 F 01000111 71 47 G 01001000 72 48 H 01001001 73 49 I 01001010 74 4A J 01001011 75 4B K 01001100 76 4C L 01001101 77 4D M 01001110 78 4E N 01001111 79 4F O 01010000 80 50 P 01010001 81 51 Q 01010010 82 52 R 01010011 83 53 S 01010100 84 54 T 01010101 85 55 U 01010110 86 56 V 01010111 87 57 W 01011000 88 58 X 01011001 89 59 Y 01011010 90 5A Z 01011011 91 5B [ 01011100 92 5C \\ 01011101 93 5D ] 01011110 94 5E ^ 01011111 95 5F _ 01100000 96 60 ` 01100001 97 61 a 01100010 98 62 b 01100011 99 63 c 01100100 100 64 d 01100101 101 65 e 01100110 102 66 f 01100111 103 67 g 01101000 104 68 h 01101001 105 69 i 01101010 106 6A j 01101011 107 6B k 01101100 108 6C l 01101101 109 6D m 01101110 110 6E n 01101111 111 6F o 01110000 112 70 p 01110001 113 71 q 01110010 114 72 r 01110011 115 73 s 01110100 116 74 t 01110101 117 75 u 01110110 118 76 v 01110111 119 77 w 01111000 120 78 x 01111001 121 79 y 01111010 122 7A z 01111011 123 7B { 01111100 124 7C 01111101 125 7D } 01111110 126 7E ~ 01111111 127 7F DEL (delete) 删除 键码值 Key Code backspace 8 tab 9 enter 13 shift 16 ctrl 17 alt 18 pause/break 19 caps lock 20 escape 27 page up 33 page down 34 end 35 home 36 left arrow 37 up arrow 38 right arrow 39 down arrow 40 insert 45 delete 46 0 48 1 49 2 50 3 51 4 52 5 53 6 54 7 55 8 56 9 57 a 65 b 66 c 67 d 68 e 69 f 70 g 71 h 72 i 73 j 74 k 75 l 76 m 77 n 78 o 79 p 80 q 81 r 82 s 83 t 84 u 85 v 86 w 87 x 88 y 89 z 90 left window key 91 right window key 92 select key 93 numpad 0 96 numpad 1 97 numpad 2 98 numpad 3 99 numpad 4 100 numpad 5 101 numpad 6 102 numpad 7 103 numpad 8 104 numpad 9 105 multiply 106 add 107 subtract 109 decimal point 110 divide 111 f1 112 f2 113 f3 114 f4 115 f5 116 f6 117 f7 118 f8 119 f9 120 f10 121 f11 122 f12 123 num lock 144 scroll lock 145 semi-colon 186 equal sign 187 comma 188 dash 189 period 190 forward slash 191 grave accent 192 open bracket 219 back slash 220 close braket 221 single quote 222 ","date":"2022-12-01","objectID":"/posts/ascii%E7%A0%81%E9%94%AE%E5%80%BC%E7%A0%81/:0:0","tags":["编码","ASCII","查询表"],"title":"ASCII码值对照表","uri":"/posts/ascii%E7%A0%81%E9%94%AE%E5%80%BC%E7%A0%81/"}]